<!doctype html>
<html lang="nl">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Onze jongens van Oranje</title>
    <link rel="stylesheet" href="src/style.css">
</head>

<body>
<div class="aura" id="aura">
    <div class="blob red" id="bRed"></div>
    <div class="blob white" id="bWhite"></div>
    <div class="blob blue" id="bBlue"></div>
    <div class="blob neutral" id="bNeutral"></div>
</div>
<div class="noise"></div>

<div class="topTitle">Onze jongens van Oranje<br>JOEP ‚Ä¢ IVY ‚Ä¢ FAYAAZ</div>
<div id="app"></div>

<div class="bottomNav">
    <button class="pill" id="btnReset">RESET VIEW</button>
    <button class="pill" id="btnShuffle">SHUFFLE</button>
    <button class="pill" id="btnAuto">AUTO ROTATE</button>
</div>

<div class="tip" id="tip"></div>

<div class="timelineUI" id="timelineUI">
    <div class="timelineTop">
        <div class="timelineLabel" id="tlLabel">Gekozen jaar: ‚Äì</div>
    </div>

    <div class="timelineRow">
        <input id="tlRange" type="range" min="0" max="2000" step="1" value="0" />
        <div class="timelineDot" id="tlDot"></div>
    </div>

    <div class="timelineDates">
        <span id="tlMin">‚Äì</span>
        <span id="tlMid">‚Äì</span>
        <span id="tlMax">‚Äì</span>
    </div>
</div>

<script type="module">
    console.log("‚úÖ SCRIPT START");

    window.addEventListener("error", (e) => console.log("‚ùå window.error:", e?.message, e));
    window.addEventListener("unhandledrejection", (e) => console.log("‚ùå unhandledrejection:", e?.reason, e));

    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { players } from "./src/data/players.js";
    import localMap from "./src/data/players_local_map.json" with { type: "json" };

    console.log("‚úÖ imports ok:", {
        playersLen: players?.length,
        localMapKeys: Object.keys(localMap || {}).length
    });

    // ============================================================
    // ‚úÖ INSTELLINGEN (zoals LIMIT)
    // ============================================================
    const LIMIT = null;                   // bv 200, of null = alles
    const REQUIRE_DEBUT = true;           // true aanbevolen (timeline)
    const ONLY_WITH_PHOTO = false;        // true = alleen foto, false = fallback

    // ‚úÖ RANDOM LAYOUT (zonder random timeline!)
    const LAYOUT_RANDOMIZE_ON_INIT = true;
    const LAYOUT_RANDOMIZE_ON_COUNT_CHANGE = false; // true = elke keer als activeCount verandert
    // ============================================================

    // ============================================================
    // ‚úÖ TIMELINE VASTE JAREN
    // ============================================================
    const TIMELINE_START_YEAR = 1905;
    const TIMELINE_END_YEAR   = 2025;
    // ============================================================

    // ============================================================
    // ‚úÖ AUTO SPACING / SCALE (800 spelers)
    // ============================================================
    const CARD_W = 1.5;
    const CARD_H = 2.3;

    const MIN_CARD_SCALE = 0.58;
    const MAX_CARD_SCALE = 1.00;
    const HOVER_BOOST    = 1.18;

    const SPACING_MULT = 1.55;
    const MIN_RADIUS   = 6.0;
    const MAX_RADIUS   = 14.0;
    const POS_LERP     = 0.10;

    const ZOOM_MIN = 1;
    const ZOOM_MAX = 915;
    // ============================================================

    // ============================================================
    // ‚úÖ AUTO-ROTATE STOPPEN OP MOUSEMOVE + RESUME NA IDLE
    // ============================================================
    const AUTO_ROTATE_IDLE_RESUME_MS = 1800; // <-- pas aan (ms)
    let autoRotateUserEnabled = true;        // jouw knop (AUTO ROTATE) bepaalt dit
    let lastUserActivityTs = performance.now();

    function registerUserActivity(reason = "unknown") {
        lastUserActivityTs = performance.now();
        // (debug kan aan/uit)
        // console.log("üõë user activity:", reason);
    }

    function shouldAutoRotate(now) {
        if (!autoRotateUserEnabled) return false;    // knop staat uit
        if (isDragging) return false;                // tijdens drag nooit
        return (now - lastUserActivityTs) > AUTO_ROTATE_IDLE_RESUME_MS;
    }
    // ============================================================

    // -------------------------
    // Helpers
    // -------------------------
    const cleanKey = (s) =>
        String(s || "")
            .replace(/\u00A0/g, " ")
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, " ")
            .trim()
            .replace(/\s+/g, " ");

    function parseDateSafe(s) {
        const d = new Date(s);
        return Number.isFinite(d.getTime()) ? d : null;
    }

    const yearFromDate = (s) => {
        const d = parseDateSafe(s);
        return d ? d.getFullYear() : null;
    };

    function corsify(url, w = 1400) {
        const clean = url.replace(/^https?:\/\//, "");
        return `https://images.weserv.nl/?url=${encodeURIComponent(clean)}&w=${w}&output=jpg`;
    }

    const GITHUB_RAW_BASE =
        "https://raw.githubusercontent.com/Fayaaz-N/FreeTheMapv2/main/public";

    function getImgUrl(p, w = 1100){
        let src = String(p?.img || "").trim();

        // fallback
        if (!src) {
            return `${GITHUB_RAW_BASE}/img/players/fallback.jpg`;
        }

        // haal evt "/public" of leading slashes weg
        src = src.replace(/^\/?public\//, "");
        src = src.replace(/^\/+/, "");

        // als het een lokaal img-pad is ‚Üí force GitHub RAW
        if (src.startsWith("img/")) {
            return `${GITHUB_RAW_BASE}/${src}`;
        }

        // als het al een volledige http(s) url is
        if (src.startsWith("http")) {
            return src;
        }

        // laatste fallback
        return `${GITHUB_RAW_BASE}/${src}`;
    }



    function shuffleInPlace(arr){
        for(let i = arr.length - 1; i > 0; i--){
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    // -------------------------
    // Map images by name
    // -------------------------
    const localMapNormalized = new Map(
        Object.entries(localMap || {}).map(([name, url]) => [cleanKey(name), url])
    );

    let matchCount = 0;
    players.forEach((p) => {
        const hit = localMapNormalized.get(cleanKey(p?.name));
        if (hit) { p.img = hit; matchCount++; }
    });
    console.log("‚úÖ image matches (localMap):", matchCount, "/", players.length);

    // -------------------------
    // Build list (STABIEL: sort op debutYear)
    // -------------------------
    let usedPlayers = [...players];

    if (ONLY_WITH_PHOTO) {
        const before = usedPlayers.length;
        usedPlayers = usedPlayers.filter(p => String(p?.img || "").trim().length > 0);
        console.log("üñºÔ∏è ONLY_WITH_PHOTO enabled -> removed:", before - usedPlayers.length);
    } else {
        console.log("üñºÔ∏è ONLY_WITH_PHOTO disabled -> fallback for missing photos");
    }

    if (REQUIRE_DEBUT) {
        const before = usedPlayers.length;
        usedPlayers = usedPlayers.filter(p => parseDateSafe(p?.debut));
        console.log("üóìÔ∏è REQUIRE_DEBUT enabled -> removed:", before - usedPlayers.length);
    }

    usedPlayers = usedPlayers.map(p => {
        const y = yearFromDate(p?.debut);
        return { ...p, __debutYear: y };
    });

    usedPlayers.sort((a,b) => {
        const ya = (typeof a.__debutYear === "number") ? a.__debutYear : 9999;
        const yb = (typeof b.__debutYear === "number") ? b.__debutYear : 9999;
        return ya - yb;
    });

    if (typeof LIMIT === "number" && Number.isFinite(LIMIT) && LIMIT > 0) {
        usedPlayers = usedPlayers.slice(0, LIMIT);
        console.log("‚úÇÔ∏è LIMIT applied:", LIMIT);
    } else {
        console.log("‚úÇÔ∏è LIMIT disabled (null)");
    }

    console.log("‚úÖ usedPlayers final:", usedPlayers.length);

    // -------------------------
    // Aura cursor animation
    // -------------------------
    const state = { x: innerWidth*0.5, y: innerHeight*0.5, tx: innerWidth*0.5, ty: innerHeight*0.5 };
    const bRed = document.getElementById("bRed");
    const bWhite = document.getElementById("bWhite");
    const bBlue = document.getElementById("bBlue");
    const bNeutral = document.getElementById("bNeutral");

    // ‚úÖ mousemove = activity -> stopt autoRotate (en resume later)
    window.addEventListener("pointermove", (e)=>{
        state.tx=e.clientX; state.ty=e.clientY;
        registerUserActivity("pointermove");
    });

    function place(el, x, y, s=1){ if(el) el.style.transform = `translate3d(${x}px, ${y}px,0) scale(${s})`; }
    (function auraLoop(){
        state.x += (state.tx - state.x) * 0.08;
        state.y += (state.ty - state.y) * 0.08;
        place(bRed,     state.x - 560*0.42, state.y - 560*0.62, 1.05);
        place(bWhite,   state.x - 560*0.12, state.y - 560*0.25, 0.95);
        place(bBlue,    state.x - 560*0.62, state.y - 560*0.08, 1.10);
        place(bNeutral, state.x - 760*0.45, state.y - 760*0.40, 1.00);
        requestAnimationFrame(auraLoop);
    })();

    // -------------------------
    // Three.js setup
    // -------------------------
    const app = document.getElementById("app");
    const tip = document.getElementById("tip");

    const scene = new THREE.Scene();
    scene.background = null;

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 900);
    camera.position.set(0, 0, 22);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 1.1));
    const dir = new THREE.DirectionalLight(0xffffff, 0.35);
    dir.position.set(10, 12, 14);
    scene.add(dir);

    // controls
    let targetRotX = 0, targetRotY = 0;
    let rotX = 0, rotY = 0;
    let zoom = 22;

    let isDragging = false;
    let lastX = 0, lastY = 0;

    renderer.domElement.addEventListener("pointerdown", (e)=>{
        registerUserActivity("pointerdown");
        isDragging = true;
        lastX = e.clientX; lastY = e.clientY;
        renderer.domElement.setPointerCapture(e.pointerId);
    });

    renderer.domElement.addEventListener("pointermove", (e)=>{
        registerUserActivity("drag-move");
        if(!isDragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        targetRotY += dx * 0.005;
        targetRotX += dy * 0.005;
        targetRotX = Math.max(-1.2, Math.min(1.2, targetRotX));
    });

    renderer.domElement.addEventListener("pointerup", ()=>{
        registerUserActivity("pointerup");
        isDragging = false;
    });

    window.addEventListener("wheel", (e)=>{
        registerUserActivity("wheel");

        const delta = Math.sign(e.deltaY);

        // ‚úÖ ALLEEN ZOOM ‚Äî GEEN ROTATIE
        zoom = Math.max(
            ZOOM_MIN,
            Math.min(ZOOM_MAX, zoom + delta * 1.1)
        );
    }, { passive:true });


    // -------------------------
    // Cards
    // -------------------------
    const group = new THREE.Group();
    scene.add(group);

    THREE.Cache.enabled = true;
    const texLoader = new THREE.TextureLoader();
    texLoader.setCrossOrigin("anonymous");

    const geo = new THREE.PlaneGeometry(CARD_W, CARD_H);

    function addFrame(mesh){
        const frameGeo = new THREE.PlaneGeometry(CARD_W + 0.07, CARD_H + 0.07);
        const frameMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.92,
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false
        });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        frame.position.set(0,0,-0.03);
        frame.renderOrder = 0;
        mesh.renderOrder = 1;
        mesh.add(frame);
    }

    function fibonacciSpherePoints(count, r){
        const pts = [];
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));
        for(let i = 0; i < count; i++){
            const t = count === 1 ? 0 : i / (count - 1);
            const y = 1 - 2 * t;
            const radiusAtY = Math.sqrt(1 - y * y);
            const theta = goldenAngle * i;
            const x = Math.cos(theta) * radiusAtY;
            const z = Math.sin(theta) * radiusAtY;
            pts.push(new THREE.Vector3(x, y, z).multiplyScalar(r));
        }
        return pts;
    }

    const cards = [];
    const TOTAL = usedPlayers.length;

    console.log("üß± creating meshes:", TOTAL);

    for (let i = 0; i < TOTAL; i++){
        const p = usedPlayers[i];

        const mat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const url = getImgUrl(p, 1100);
        if (i < 3) console.log("üñºÔ∏è texture url:", i, p.name, url);

        texLoader.load(
            url,
            (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace;
                mat.map = tex;
                mat.needsUpdate = true;
            },
            undefined,
            (err) => {
                console.log("‚ùå texture FAIL:", p.name, url, err);
                mat.color.setHex(0xededed);
                mat.needsUpdate = true;
            }
        );

        const mesh = new THREE.Mesh(geo, mat);
        mesh.userData = p;
        mesh.visible = false;
        mesh.userData.__baseScale = 1;
        mesh.scale.setScalar(1);

        addFrame(mesh);
        group.add(mesh);
        cards.push(mesh);
    }

    console.log("‚úÖ meshes created:", cards.length);

    // -------------------------
    // Tooltip + hover (RAYCAST)
    // -------------------------
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hovered = null;

    function setTip(show, x=0, y=0, html=""){
        if(!tip) return;
        tip.style.opacity = show ? 1 : 0;
        if(show){
            tip.style.left = (x + 14) + "px";
            tip.style.top  = (y + 14) + "px";
            tip.innerHTML = html;
        }
    }

    // -------------------------
    // Timeline fixed years 1905‚Äì2025
    // -------------------------
    const tlRange = document.getElementById("tlRange");
    const tlLabel = document.getElementById("tlLabel");
    const tlDot   = document.getElementById("tlDot");
    const tlMinEl = document.getElementById("tlMin");
    const tlMidEl = document.getElementById("tlMid");
    const tlMaxEl = document.getElementById("tlMax");

    tlMinEl.textContent = TIMELINE_START_YEAR;
    tlMidEl.textContent = Math.round((TIMELINE_START_YEAR + TIMELINE_END_YEAR) * 0.5);
    tlMaxEl.textContent = TIMELINE_END_YEAR;

    tlRange.min = 0;
    tlRange.max = 2000;
    tlRange.value = 0;

    let chosenYear = TIMELINE_START_YEAR;

    let activeCount = 0;
    let targetRadius = MIN_RADIUS;
    let spherePoints = [];

    let layoutOrder = [];

    function setDotFromRange(){
        const v = Number(tlRange.value);
        const f = v / Number(tlRange.max);
        const x = f * tlRange.clientWidth;
        tlDot.style.left = `${x}px`;
    }

    function setYearFromSlider(){
        const v = Number(tlRange.value);
        const f = v / Number(tlRange.max);
        const y = TIMELINE_START_YEAR + (TIMELINE_END_YEAR - TIMELINE_START_YEAR) * f;
        chosenYear = Math.round(y);
        tlLabel.textContent = `Gekozen jaar: ${chosenYear}`;
        setDotFromRange();
    }

    function computeActiveCountByYear(y){
        let lo = 0;
        let hi = usedPlayers.length;
        while (lo < hi){
            const mid = (lo + hi) >> 1;
            const dY = (typeof usedPlayers[mid].__debutYear === "number") ? usedPlayers[mid].__debutYear : 9999;
            if (dY <= y) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }

    function computeRadius(n){
        const desired = (CARD_W * SPACING_MULT);
        const r = desired * Math.sqrt(Math.max(1, n) / (4 * Math.PI));
        return Math.min(MAX_RADIUS, Math.max(MIN_RADIUS, r));
    }

    function computeCardBaseScale(n){
        const REF = 140;
        const s = Math.sqrt(REF / Math.max(1, n));
        return Math.max(MIN_CARD_SCALE, Math.min(MAX_CARD_SCALE, s));
    }

    function randomizeLayoutOrder(count){
        layoutOrder = Array.from({length: count}, (_, i) => i);
        shuffleInPlace(layoutOrder);
    }

    function rebuildLayoutIfNeeded(){
        const nextCount = computeActiveCountByYear(chosenYear);

        if (nextCount !== activeCount) {
            activeCount = nextCount;

            targetRadius = computeRadius(activeCount);
            spherePoints = fibonacciSpherePoints(activeCount, targetRadius);

            if (layoutOrder.length !== activeCount) {
                layoutOrder = Array.from({length: activeCount}, (_, i) => i);
                if (LAYOUT_RANDOMIZE_ON_INIT && activeCount > 0 && layoutOrder.every((v,i)=>v===i)) {
                    shuffleInPlace(layoutOrder);
                }
                if (LAYOUT_RANDOMIZE_ON_COUNT_CHANGE) shuffleInPlace(layoutOrder);
            }

            const baseS = computeCardBaseScale(activeCount);

            for (let i = 0; i < cards.length; i++){
                const m = cards[i];
                const on = i < activeCount;

                m.visible = on;
                if (on) {
                    m.userData.__baseScale = baseS;
                    m.scale.setScalar(baseS);
                }
            }

            if (hovered) hovered = null;
            setTip(false);

            zoom = Math.max(zoom, targetRadius + 8);

            console.log("üü† ACTIVE CHANGED:", {
                chosenYear,
                activeCount,
                radius: targetRadius.toFixed(2),
                baseScale: baseS.toFixed(3),
                layoutRandom: LAYOUT_RANDOMIZE_ON_COUNT_CHANGE
            });
        }
    }

    function updateLayoutPositions(){
        for (let i = 0; i < activeCount; i++){
            const m = cards[i];
            const targetIndex = layoutOrder[i] ?? i;
            const target = spherePoints[targetIndex];
            if (!target) continue;
            m.position.lerp(target, POS_LERP);
            m.lookAt(0,0,0);
        }
    }

    // hover uses activeCount
    window.addEventListener("pointermove", (e)=>{
        // (mousemove is ook activity)
        // registerUserActivity zit al boven bij aura listener, maar dubbel is ok
        mouse.x = (e.clientX / innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const visibleCards = cards.slice(0, activeCount);
        const hits = raycaster.intersectObjects(visibleCards, true);
        const hit = hits.length ? hits[0].object : null;

        if(hit && hit.userData?.name){
            if(hovered !== hit){
                if(hovered) hovered.scale.setScalar(hovered.userData.__baseScale || 1);
                hovered = hit;

                const base = hovered.userData.__baseScale || 1;
                hovered.scale.setScalar(base * HOVER_BOOST);
            }

            const p = hit.userData;
            const dy = yearFromDate(p.debut);
            setTip(true, e.clientX, e.clientY,
                `<b>${p.name}</b>
         <div style="font-size:11px;color:#555;margin-top:4px">
           ${p.country || "‚Äì"} ‚Ä¢ ${p.club || "‚Äì"}<br>
           Debuut: <b>${dy ?? "‚Äì"}</b>
         </div>`
            );
        } else {
            if(hovered) hovered.scale.setScalar(hovered.userData.__baseScale || 1);
            hovered = null;
            setTip(false);
        }
    });

    tlRange.addEventListener("input", ()=>{
        registerUserActivity("timeline");
        setYearFromSlider();
        rebuildLayoutIfNeeded();
    });

    // init
    setYearFromSlider();
    activeCount = 0;
    layoutOrder = [];
    if (LAYOUT_RANDOMIZE_ON_INIT) randomizeLayoutOrder(Math.max(1, activeCount));
    rebuildLayoutIfNeeded();

    // -------------------------
    // Buttons
    // -------------------------
    document.getElementById("btnReset").addEventListener("click", ()=>{
        registerUserActivity("reset");
        targetRotX = 0; targetRotY = 0; zoom = 22;
        console.log("üîÅ reset view");
    });

    document.getElementById("btnShuffle").addEventListener("click", ()=>{
        registerUserActivity("shuffle");
        if (activeCount <= 1) return;
        randomizeLayoutOrder(activeCount);
        console.log("üîÄ shuffle layout (order randomized):", { activeCount });
    });

    document.getElementById("btnAuto").addEventListener("click", ()=>{
        registerUserActivity("auto-toggle");
        autoRotateUserEnabled = !autoRotateUserEnabled;

        // als je hem AAN zet ‚Üí meteen kunnen draaien (zonder wachten)
        if (autoRotateUserEnabled) {
            lastUserActivityTs = performance.now() - AUTO_ROTATE_IDLE_RESUME_MS - 1;
        }

        document.getElementById("btnAuto").textContent = autoRotateUserEnabled ? "AUTO ROTATE" : "AUTO OFF";
        console.log("üåÄ autoRotateUserEnabled:", autoRotateUserEnabled);
    });

    // -------------------------
    // Main loop
    // -------------------------
    function tick(){
        const now = performance.now();

        rotX += (targetRotX - rotX) * 0.08;
        rotY += (targetRotY - rotY) * 0.08;

        // ‚úÖ AUTO ROTATE: alleen als user idle is
        if (shouldAutoRotate(now)) {
            targetRotY += 0.0035;
        }

        const r = zoom;
        const x = r * Math.sin(rotY) * Math.cos(rotX);
        const y = r * Math.sin(rotX);
        const z = r * Math.cos(rotY) * Math.cos(rotX);

        camera.position.set(x,y,z);
        camera.lookAt(0,0,0);

        updateLayoutPositions();
        renderer.render(scene, camera);

        requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    window.addEventListener("resize", ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });

    console.log("‚úÖ INIT DONE", {
        total: TOTAL,
        timeline: { TIMELINE_START_YEAR, TIMELINE_END_YEAR },
        settings: { LIMIT, REQUIRE_DEBUT, ONLY_WITH_PHOTO, LAYOUT_RANDOMIZE_ON_INIT, LAYOUT_RANDOMIZE_ON_COUNT_CHANGE },
        autoRotate: { AUTO_ROTATE_IDLE_RESUME_MS }
    });
</script>
</body>
</html>
