<!doctype html>
<html lang="nl">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Onze jongens van Oranje</title>
    <link rel="stylesheet" href="src/style.css">

    <style>
        /* container bovenop de three canvas */
        #app{ position:relative; }

        /* start panel die IN #app zit */
        .startPanel{
            position:absolute;
            inset:0;
            z-index:50;
            display:grid;
            place-items:center;
            pointer-events:auto; /* overlay vangt clicks */
        }
        .startPanel.hidden{ display:none; }

        .startPanel .startBg{
            position:absolute;
            width:75%;
            height:75%;
            object-fit:contain;
            border-radius:16px;
            filter:saturate(1.05) contrast(1.05);
            pointer-events:none; /* image zelf vangt geen events */
        }

        .startPanel .startInner{
            position:relative;
            display:flex;
            flex-direction:column;
            align-items:center;
            gap:14px;
            padding:18px 18px;
            text-align:center;
            max-width:520px;
            pointer-events:none; /* alleen knop krijgt pointer-events */
        }

        .startPanel .startTitle{
            font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
            font-size:12px;
            letter-spacing:.18em;
            text-transform:uppercase;
            color:#fff;
            opacity:.95;
            line-height:1.35;
            text-shadow:0 12px 30px rgba(0,0,0,.45);
            user-select:none;
            pointer-events:none;
        }

        /* âœ… knop onderin het scherm (binnen overlay) */
        .startBtnWrap{
            position:absolute;
            left:0;
            right:0;
            bottom:18px;
            display:flex;
            justify-content:center;
            pointer-events:auto;
            z-index:60;
        }

        .startBtn{
            border:0;
            padding:12px 18px;
            border-radius:999px;
            cursor:pointer;
            background:#fff;
            color:#111;
            font-weight:700;
            letter-spacing:.06em;
            box-shadow:0 14px 40px rgba(0,0,0,.35);
            transform:translateZ(0);
            pointer-events:auto;
        }
        .startBtn:active{ transform:scale(.98); }

        /* UI verbergen tot start */
        .uiHidden{ opacity:0; pointer-events:none; }
        .uiHidden.show{ opacity:1; pointer-events:auto; }
    </style>
</head>

<body>
<div class="aura" id="aura">
    <div class="blob red" id="bRed"></div>
    <div class="blob white" id="bWhite"></div>
    <div class="blob blue" id="bBlue"></div>
    <div class="blob neutral" id="bNeutral"></div>
</div>
<div class="noise"></div>

<div class="topTitle uiHidden" id="topTitle">Onze jongens van Oranje<br>JOEP â€¢ IVY â€¢ FAYAAZ</div>

<!-- âœ… Alles gebeurt in #app -->
<div id="app">
    <!-- âœ… Start state overlay IN de app-div -->
    <div class="startPanel" id="startPanel" aria-hidden="false">
        <img class="startBg" id="startBg" src="/public/team.jpg" alt="Start placeholder" />
        <div class="startInner">
<!--            <div class="startTitle">Onze jongens van Oranje</div>-->
        </div>

        <!-- âœ… knop onderin -->
        <div class="startBtnWrap">
            <button class="startBtn" id="btnStart" type="button">START EXPERIENCE</button>
        </div>
    </div>
</div>

<div class="bottomNav uiHidden" id="bottomNav">
    <div class=" " id="timelineUI">
        <div class="timelineTop">
            <div class="timelineLabel" id="tlLabel">Gekozen jaar: â€“</div>
        </div>

        <div class="timelineRow">
            <input id="tlRange" type="range" min="0" max="2000" step="1" value="0" />
            <div class="timelineDot" id="tlDot"></div>
        </div>

        <div class="timelineDates">
            <span id="tlMin">â€“</span>
            <span id="tlMid">â€“</span>
            <span id="tlMax">â€“</span>
        </div>
    </div>
    <button class="pil uiHidden" id="btnReset" style="display:none;">RESET VIEW</button>
    <button class="pill uiHidden" id="btnShuffle" style="display:none;">SHUFFLE</button>
    <button class="pill uiHidden" id="btnAuto" style="display:none;">AUTO ROTATE</button>
</div>

<div class="tip" id="tip"></div>

<div class="slider"></div>

<script type="module">
    console.log("âœ… SCRIPT START");

    window.addEventListener("error", (e) => console.log("âŒ window.error:", e?.message, e));
    window.addEventListener("unhandledrejection", (e) => console.log("âŒ unhandledrejection:", e?.reason, e));

    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { players } from "./src/data/players.js";
    import localMap from "./src/data/players_local_map.json" with { type: "json" };

    console.log("âœ… imports ok:", {
        playersLen: players?.length,
        localMapKeys: Object.keys(localMap || {}).length
    });

    // ============================================================
    // âœ… START STATE / EXPERIENCE SWITCH (IN #app)
    // ============================================================
    const startPanel  = document.getElementById("startPanel");
    const btnStart    = document.getElementById("btnStart");
    const startBg     = document.getElementById("startBg");

    const topTitleEl  = document.getElementById("topTitle");
    const bottomNavEl = document.getElementById("bottomNav");
    const timelineUIEl= document.getElementById("timelineUI");

    let experienceStarted = false;

    const GLOBE_START_IMAGE = "/public/team.jpg";

    function showUI(){
        topTitleEl?.classList.add("show");
        bottomNavEl?.classList.add("show");
        timelineUIEl?.classList.add("show");
    }
    function hideUI(){
        topTitleEl?.classList.remove("show");
        bottomNavEl?.classList.remove("show");
        timelineUIEl?.classList.remove("show");
    }

    hideUI();

    btnStart.addEventListener("click", async () => {
        if (experienceStarted) return;

        // âœ… vanaf NU pas interactie toestaan
        experienceStarted = true;

        if (startBg) startBg.src = GLOBE_START_IMAGE;
        await new Promise(r => setTimeout(r, 160));

        startPanel?.classList.add("hidden");
        showUI();

        // auto rotate direct
        lastUserActivityTs = performance.now() - AUTO_ROTATE_IDLE_RESUME_MS - 1;

        console.log("ðŸš€ EXPERIENCE STARTED");
    });
    // ============================================================

    // ============================================================
    // âœ… INSTELLINGEN
    // ============================================================
    const LIMIT = null;
    const REQUIRE_DEBUT = true;
    const ONLY_WITH_PHOTO = false;

    const LAYOUT_RANDOMIZE_ON_INIT = true;
    const LAYOUT_RANDOMIZE_ON_COUNT_CHANGE = false;

    const TIMELINE_START_YEAR = 1905;
    const TIMELINE_END_YEAR   = 2025;

    const CARD_W = 1.5;
    const CARD_H = 2.3;

    const MIN_CARD_SCALE = 0.58;
    const MAX_CARD_SCALE = 1.00;
    const HOVER_BOOST    = 1.18;

    const SPACING_MULT = 1.55;
    const MIN_RADIUS   = 6.0;
    const MAX_RADIUS   = 14.0;
    const POS_LERP     = 0.10;

    const ZOOM_MIN = 1;
    const ZOOM_MAX = 915;

    const AUTO_ROTATE_IDLE_RESUME_MS = 1800;
    let autoRotateUserEnabled = true;
    let lastUserActivityTs = performance.now();

    function registerUserActivity(reason = "unknown") {
        lastUserActivityTs = performance.now();
    }

    function shouldAutoRotate(now) {
        if (!autoRotateUserEnabled) return false;
        if (isDragging) return false;
        return (now - lastUserActivityTs) > AUTO_ROTATE_IDLE_RESUME_MS;
    }
    // ============================================================

    // -------------------------
    // Helpers
    // -------------------------
    const cleanKey = (s) =>
        String(s || "")
            .replace(/\u00A0/g, " ")
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, " ")
            .trim()
            .replace(/\s+/g, " ");

    function parseDateSafe(s) {
        const d = new Date(s);
        return Number.isFinite(d.getTime()) ? d : null;
    }

    const yearFromDate = (s) => {
        const d = parseDateSafe(s);
        return d ? d.getFullYear() : null;
    };

    const GITHUB_RAW_BASE =
        "https://raw.githubusercontent.com/Fayaaz-N/FreeTheMapv2/main/public";

    function getImgUrl(p, w = 1100){
        let src = String(p?.img || "").trim();
        if (!src) return `${GITHUB_RAW_BASE}/img/players/fallback.jpg`;

        src = src.replace(/^\/?public\//, "");
        src = src.replace(/^\/+/, "");

        if (src.startsWith("img/")) return `${GITHUB_RAW_BASE}/${src}`;
        if (src.startsWith("http")) return src;

        return `${GITHUB_RAW_BASE}/${src}`;
    }

    function shuffleInPlace(arr){
        for(let i = arr.length - 1; i > 0; i--){
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    // -------------------------
    // Map images by name
    // -------------------------
    const localMapNormalized = new Map(
        Object.entries(localMap || {}).map(([name, url]) => [cleanKey(name), url])
    );

    let matchCount = 0;
    players.forEach((p) => {
        const hit = localMapNormalized.get(cleanKey(p?.name));
        if (hit) { p.img = hit; matchCount++; }
    });
    console.log("âœ… image matches (localMap):", matchCount, "/", players.length);

    // -------------------------
    // Build list (STABIEL: sort op debutYear)
    // -------------------------
    let usedPlayers = [...players];

    if (ONLY_WITH_PHOTO) {
        const before = usedPlayers.length;
        usedPlayers = usedPlayers.filter(p => String(p?.img || "").trim().length > 0);
        console.log("ðŸ–¼ï¸ ONLY_WITH_PHOTO enabled -> removed:", before - usedPlayers.length);
    } else {
        console.log("ðŸ–¼ï¸ ONLY_WITH_PHOTO disabled -> fallback for missing photos");
    }

    if (REQUIRE_DEBUT) {
        const before = usedPlayers.length;
        usedPlayers = usedPlayers.filter(p => parseDateSafe(p?.debut));
        console.log("ðŸ—“ï¸ REQUIRE_DEBUT enabled -> removed:", before - usedPlayers.length);
    }

    usedPlayers = usedPlayers.map(p => {
        const y = yearFromDate(p?.debut);
        return { ...p, __debutYear: y };
    });

    usedPlayers.sort((a,b) => {
        const ya = (typeof a.__debutYear === "number") ? a.__debutYear : 9999;
        const yb = (typeof b.__debutYear === "number") ? b.__debutYear : 9999;
        return ya - yb;
    });

    console.log("âœ… usedPlayers final:", usedPlayers.length);

    // -------------------------
    // Aura cursor animation
    // -------------------------
    const state = { x: innerWidth*0.5, y: innerHeight*0.5, tx: innerWidth*0.5, ty: innerHeight*0.5 };
    const bRed = document.getElementById("bRed");
    const bWhite = document.getElementById("bWhite");
    const bBlue = document.getElementById("bBlue");
    const bNeutral = document.getElementById("bNeutral");

    window.addEventListener("pointermove", (e)=>{
        state.tx=e.clientX; state.ty=e.clientY;
        registerUserActivity("pointermove");
    });

    function place(el, x, y, s=1){ if(el) el.style.transform = `translate3d(${x}px, ${y}px,0) scale(${s})`; }
    (function auraLoop(){
        state.x += (state.tx - state.x) * 0.08;
        state.y += (state.ty - state.y) * 0.08;
        place(bRed,     state.x - 560*0.42, state.y - 560*0.62, 1.05);
        place(bWhite,   state.x - 560*0.12, state.y - 560*0.25, 0.95);
        place(bBlue,    state.x - 560*0.62, state.y - 560*0.08, 1.10);
        place(bNeutral, state.x - 760*0.45, state.y - 760*0.40, 1.00);
        requestAnimationFrame(auraLoop);
    })();

    // -------------------------
    // Three.js setup
    // -------------------------
    const app = document.getElementById("app");
    const tip = document.getElementById("tip");

    const scene = new THREE.Scene();
    scene.background = null;

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 900);
    camera.position.set(0, 0, 22);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 1.1));
    const dir = new THREE.DirectionalLight(0xffffff, 0.35);
    dir.position.set(10, 12, 14);
    scene.add(dir);

    // controls
    let targetRotX = 0, targetRotY = 0;
    let rotX = 0, rotY = 0;
    let zoom = 22;

    let isDragging = false;
    let lastX = 0, lastY = 0;

    renderer.domElement.addEventListener("pointerdown", (e)=>{
        if (!experienceStarted) return;   // âœ… geen interactie vÃ³Ã³r start
        registerUserActivity("pointerdown");
        isDragging = true;
        lastX = e.clientX; lastY = e.clientY;
        renderer.domElement.setPointerCapture(e.pointerId);
    });

    renderer.domElement.addEventListener("pointermove", (e)=>{
        if (!experienceStarted) return;   // âœ… geen interactie vÃ³Ã³r start
        registerUserActivity("drag-move");
        if(!isDragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        targetRotY += dx * 0.005;
        targetRotX += dy * 0.005;
        targetRotX = Math.max(-1.2, Math.min(1.2, targetRotX));
    });

    renderer.domElement.addEventListener("pointerup", ()=>{
        if (!experienceStarted) return;   // âœ… geen interactie vÃ³Ã³r start
        registerUserActivity("pointerup");
        isDragging = false;
    });

    window.addEventListener("wheel", (e)=>{
        if (!experienceStarted) return;   // âœ… geen interactie vÃ³Ã³r start
        registerUserActivity("wheel");
        const delta = Math.sign(e.deltaY);
        zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoom + delta * 1.1));
    }, { passive:true });

    // -------------------------
    // Cards
    // -------------------------
    const group = new THREE.Group();
    scene.add(group);

    THREE.Cache.enabled = true;
    const texLoader = new THREE.TextureLoader();
    texLoader.setCrossOrigin("anonymous");

    const geo = new THREE.PlaneGeometry(CARD_W, CARD_H);

    function addFrame(mesh){
        const frameGeo = new THREE.PlaneGeometry(CARD_W + 0.07, CARD_H + 0.07);
        const frameMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.92,
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false
        });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        frame.position.set(0,0,-0.03);
        frame.renderOrder = 0;
        mesh.renderOrder = 1;
        mesh.add(frame);
    }

    function fibonacciSpherePoints(count, r){
        const pts = [];
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));
        for(let i = 0; i < count; i++){
            const t = count === 1 ? 0 : i / (count - 1);
            const y = 1 - 2 * t;
            const radiusAtY = Math.sqrt(1 - y * y);
            const theta = goldenAngle * i;
            const x = Math.cos(theta) * radiusAtY;
            const z = Math.sin(theta) * radiusAtY;
            pts.push(new THREE.Vector3(x, y, z).multiplyScalar(r));
        }
        return pts;
    }

    const cards = [];
    const TOTAL = usedPlayers.length;

    for (let i = 0; i < TOTAL; i++){
        const p = usedPlayers[i];

        const mat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const url = getImgUrl(p, 1100);

        texLoader.load(
            url,
            (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace;
                mat.map = tex;
                mat.needsUpdate = true;
            },
            undefined,
            (err) => {
                console.log("âŒ texture FAIL:", p.name, url, err);
                mat.color.setHex(0xededed);
                mat.needsUpdate = true;
            }
        );

        const mesh = new THREE.Mesh(geo, mat);
        mesh.userData = p;
        mesh.visible = false;
        mesh.userData.__baseScale = 1;
        mesh.scale.setScalar(1);

        addFrame(mesh);
        group.add(mesh);
        cards.push(mesh);
    }

    // -------------------------
    // Tooltip + hover (âœ… niet door foto heen)
    // -------------------------
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hovered = null;

    function setTip(show, x=0, y=0, html=""){
        if(!tip) return;
        tip.style.opacity = show ? 1 : 0;
        if(show){
            tip.style.left = (x + 14) + "px";
            tip.style.top  = (y + 14) + "px";
            tip.innerHTML = html;
        }
    }

    function setMouseFromEvent(e){
        const rect = renderer.domElement.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        mouse.x = x * 2 - 1;
        mouse.y = -(y * 2 - 1);
    }

    renderer.domElement.addEventListener("pointermove", (e)=>{
        if (!experienceStarted) {
            // âœ… zolang start overlay er is: nooit hover, nooit tooltip
            if (hovered) hovered.scale.setScalar(hovered.userData.__baseScale || 1);
            hovered = null;
            setTip(false);
            return;
        }

        setMouseFromEvent(e);
        raycaster.setFromCamera(mouse, camera);

        const visibleCards = cards.slice(0, activeCount);
        const hits = raycaster.intersectObjects(visibleCards, true);
        const hit = hits.length ? hits[0].object : null;

        if(hit && hit.userData?.name){
            if(hovered !== hit){
                if(hovered) hovered.scale.setScalar(hovered.userData.__baseScale || 1);
                hovered = hit;

                const base = hovered.userData.__baseScale || 1;
                hovered.scale.setScalar(base * HOVER_BOOST);
            }

            const p = hit.userData;
            const dy = yearFromDate(p.debut);
            setTip(true, e.clientX, e.clientY,
                `<b>${p.name}</b>
         <div style="font-size:11px;color:#555;margin-top:4px">
           ${p.country || "â€“"} â€¢ ${p.club || "â€“"}<br>
           Debuut: <b>${dy ?? "â€“"}</b>
         </div>`
            );
        } else {
            if(hovered) hovered.scale.setScalar(hovered.userData.__baseScale || 1);
            hovered = null;
            setTip(false);
        }
    });

    renderer.domElement.addEventListener("pointerleave", ()=>{
        if(hovered) hovered.scale.setScalar(hovered.userData.__baseScale || 1);
        hovered = null;
        setTip(false);
    });

    // -------------------------
    // Timeline fixed years 1905â€“2025
    // -------------------------
    const tlRange = document.getElementById("tlRange");
    const tlLabel = document.getElementById("tlLabel");
    const tlDot   = document.getElementById("tlDot");
    const tlMinEl = document.getElementById("tlMin");
    const tlMidEl = document.getElementById("tlMid");
    const tlMaxEl = document.getElementById("tlMax");

    tlMinEl.textContent = TIMELINE_START_YEAR;
    tlMidEl.textContent = Math.round((TIMELINE_START_YEAR + TIMELINE_END_YEAR) * 0.5);
    tlMaxEl.textContent = TIMELINE_END_YEAR;

    tlRange.min = 0;
    tlRange.max = 2000;
    tlRange.value = 0;

    let chosenYear = TIMELINE_START_YEAR;

    let activeCount = 0;
    let targetRadius = MIN_RADIUS;
    let spherePoints = [];
    let layoutOrder = [];

    function setDotFromRange(){
        const v = Number(tlRange.value);
        const f = v / Number(tlRange.max);
        const x = f * tlRange.clientWidth;
        tlDot.style.left = `${x}px`;
    }

    function setYearFromSlider(){
        const v = Number(tlRange.value);
        const f = v / Number(tlRange.max);
        const y = TIMELINE_START_YEAR + (TIMELINE_END_YEAR - TIMELINE_START_YEAR) * f;
        chosenYear = Math.round(y);
        tlLabel.textContent = `Gekozen jaar: ${chosenYear}`;
        setDotFromRange();
    }

    function computeActiveCountByYear(y){
        let lo = 0;
        let hi = usedPlayers.length;
        while (lo < hi){
            const mid = (lo + hi) >> 1;
            const dY = (typeof usedPlayers[mid].__debutYear === "number") ? usedPlayers[mid].__debutYear : 9999;
            if (dY <= y) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }

    function computeRadius(n){
        const desired = (CARD_W * SPACING_MULT);
        const r = desired * Math.sqrt(Math.max(1, n) / (4 * Math.PI));
        return Math.min(MAX_RADIUS, Math.max(MIN_RADIUS, r));
    }

    function computeCardBaseScale(n){
        const REF = 140;
        const s = Math.sqrt(REF / Math.max(1, n));
        return Math.max(MIN_CARD_SCALE, Math.min(MAX_CARD_SCALE, s));
    }

    function randomizeLayoutOrder(count){
        layoutOrder = Array.from({length: count}, (_, i) => i);
        shuffleInPlace(layoutOrder);
    }

    function rebuildLayoutIfNeeded(){
        const nextCount = computeActiveCountByYear(chosenYear);

        if (nextCount !== activeCount) {
            activeCount = nextCount;

            targetRadius = computeRadius(activeCount);
            spherePoints = fibonacciSpherePoints(activeCount, targetRadius);

            if (layoutOrder.length !== activeCount) {
                layoutOrder = Array.from({length: activeCount}, (_, i) => i);
                if (LAYOUT_RANDOMIZE_ON_INIT && activeCount > 0 && layoutOrder.every((v,i)=>v===i)) {
                    shuffleInPlace(layoutOrder);
                }
                if (LAYOUT_RANDOMIZE_ON_COUNT_CHANGE) shuffleInPlace(layoutOrder);
            }

            const baseS = computeCardBaseScale(activeCount);

            for (let i = 0; i < cards.length; i++){
                const m = cards[i];
                const on = i < activeCount;

                m.visible = on;
                if (on) {
                    m.userData.__baseScale = baseS;
                    m.scale.setScalar(baseS);
                }
            }

            if (hovered) hovered = null;
            setTip(false);

            zoom = Math.max(zoom, targetRadius + 8);
        }
    }

    function updateLayoutPositions(){
        for (let i = 0; i < activeCount; i++){
            const m = cards[i];
            const targetIndex = layoutOrder[i] ?? i;
            const target = spherePoints[targetIndex];
            if (!target) continue;
            m.position.lerp(target, POS_LERP);
            m.lookAt(0,0,0);
        }
    }

    tlRange.addEventListener("input", ()=>{
        if (!experienceStarted) return; // âœ… timeline pas na start
        registerUserActivity("timeline");
        setYearFromSlider();
        rebuildLayoutIfNeeded();
    });

    // init
    setYearFromSlider();
    activeCount = 0;
    layoutOrder = [];
    rebuildLayoutIfNeeded();

    // Main loop
    function tick(){
        const now = performance.now();

        rotX += (targetRotX - rotX) * 0.08;
        rotY += (targetRotY - rotY) * 0.08;

        if (experienceStarted && shouldAutoRotate(now)) targetRotY += 0.0035;

        const r = zoom;
        const x = r * Math.sin(rotY) * Math.cos(rotX);
        const y = r * Math.sin(rotX);
        const z = r * Math.cos(rotY) * Math.cos(rotX);

        camera.position.set(x,y,z);
        camera.lookAt(0,0,0);

        updateLayoutPositions();
        renderer.render(scene, camera);

        requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    window.addEventListener("resize", ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });

    console.log("âœ… INIT DONE");
</script>
</body>
</html>
