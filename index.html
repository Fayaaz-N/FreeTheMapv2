<!doctype html>
<html lang="nl">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Onze jongens van Oranje</title>
    <link rel="stylesheet" href="src/style.css">

</head>

<body>
<!-- Aura -->
<div class="aura" id="aura">
    <div class="blob red" id="bRed"></div>
    <div class="blob white" id="bWhite"></div>
    <div class="blob blue" id="bBlue"></div>
    <div class="blob neutral" id="bNeutral"></div>
</div>
<div class="noise"></div>

<!-- Three.js -->
<div class="topTitle">JOEP • IVY • FAYAAZ</div>
<div id="app"></div>

<div class="bottomNav">
    <button class="pill" id="btnReset">RESET VIEW</button>
    <button class="pill" id="btnShuffle">SHUFFLE</button>
    <button class="pill" id="btnAuto">AUTO ROTATE</button>
</div>

<div class="tip" id="tip"></div>

<!-- Fullscreen modal -->
<div class="modal" id="modal">
    <button class="modalClose" id="modalClose">CLOSE</button>
    <div class="modalInner">
        <div class="modalLeft">
            <div class="modalKicker" id="mKicker">FREE THE MAP • PLAYER</div>

            <div>
                <h1 class="modalTitle" id="mName">Naam</h1>
                <div class="modalSub" id="mSub">Club • Seizoen</div>
            </div>

            <div class="typeBox" id="mType"></div>

            <div class="metaGrid" id="mMeta"></div>

            <div class="sourceLinks" id="mLinks"></div>
        </div>

        <div class="modalRight">
            <img id="mImg" alt="player photo"/>
        </div>
    </div>
</div>

<script type="module">
    console.log("SCRIPT START");


    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import {players} from "./src/data/players.js";
    import localMap from "./src/data/players_local_map.json" with { type: "json" };

    console.log("players import:", players);
    console.log("localMap import:", localMap);

    // ===== local img map -> match op naam =====
    const cleanKey = (s) =>
        String(s || "")
            .replace(/\u00A0/g, " ")
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // accents weg
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, " ")
            .trim()
            .replace(/\s+/g, " ");

    const localMapNormalized = new Map(
        Object.entries(localMap).map(([name, url]) => [cleanKey(name), url])
    );
    console.log("Normalized localMap keys:", [...localMapNormalized.keys()].slice(0, 10));
    console.log("First player name:", players[0]?.name, "=>", cleanKey(players[0]?.name));

    // vul img automatisch vanuit localMap als img leeg is of extern
    // players.forEach(p => {
    //     const hit = localMapNormalized.get(cleanKey(p.name));
    //     if (hit) p.img = hit; // bv "/img/players/wilbert-suvrijn.jpg"
    // });

    players.forEach(p => {
        const k = cleanKey(p.name);
        const hit = localMapNormalized.get(k);

        if (!hit) {
            console.warn("❌ NO IMG MATCH FOR:", p.name, "->", k);
        } else {
            console.log("✅ IMG MATCH:", p.name, "->", hit);
            p.img = hit;
        }
    });


    // helper: als img lokaal is -> direct, als extern -> corsify
    function getImgUrl(p, w = 1100) {
        const src = String("public"+ p?.img || "").trim();
        if (!src) return "/img/players/fallback.jpg";

        // ✅ lokaal in Vite public: "/img/players/..."
        if (src.startsWith("/public/img")) return src;

        // (optioneel) relatief pad
        if (src.startsWith("./")) return src;

        // extern
        if (src.startsWith("http")) return corsify(src, w);

        return src;
    }




    // =========================
    // Aura cursor animation
    // =========================
    const state = {
        x: innerWidth*0.5, y: innerHeight*0.5,
        tx: innerWidth*0.5, ty: innerHeight*0.5
    };
    const bRed = document.getElementById("bRed");
    const bWhite = document.getElementById("bWhite");
    const bBlue = document.getElementById("bBlue");
    const bNeutral = document.getElementById("bNeutral");

    window.addEventListener("pointermove", (e)=>{ state.tx=e.clientX; state.ty=e.clientY; });

    function place(el, x, y, s=1){ el.style.transform = `translate3d(${x}px, ${y}px,0) scale(${s})`; }

    (function auraLoop(){
        state.x += (state.tx - state.x) * 0.08;
        state.y += (state.ty - state.y) * 0.08;
        place(bRed,     state.x - 560*0.42, state.y - 560*0.62, 1.05);
        place(bWhite,   state.x - 560*0.12, state.y - 560*0.25, 0.95);
        place(bBlue,    state.x - 560*0.62, state.y - 560*0.08, 1.10);
        place(bNeutral, state.x - 760*0.45, state.y - 760*0.40, 1.00);
        requestAnimationFrame(auraLoop);
    })();

    // =========================
    // CORS image proxy for WebGL + modal image
    // =========================
    function corsify(url, w=1400){
        const clean = url.replace(/^https?:\/\//, "");
        return `https://images.weserv.nl/?url=${encodeURIComponent(clean)}&w=${w}&output=jpg`;
    }

    // =========================
    // DATA (zet hier jouw package/json fotos + info)
    // =========================


    // =========================
    // Three.js setup
    // =========================
    const app = document.getElementById("app");
    const tip = document.getElementById("tip");

    const scene = new THREE.Scene();
    scene.background = null; // transparent so aura shows through

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 0, 22);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 1.1));
    const dir = new THREE.DirectionalLight(0xffffff, 0.35);
    dir.position.set(10, 12, 14);
    scene.add(dir);

    // Camera controls
    let targetRotX = 0, targetRotY = 0;
    let rotX = 0, rotY = 0;
    let zoom = 22;

    let isDragging = false;
    let lastX = 0, lastY = 0;

    renderer.domElement.addEventListener("pointerdown", (e)=>{
        isDragging = true;
        lastX = e.clientX; lastY = e.clientY;
        renderer.domElement.setPointerCapture(e.pointerId);
    });
    renderer.domElement.addEventListener("pointermove", (e)=>{
        if(!isDragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        targetRotY += dx * 0.005;
        targetRotX += dy * 0.005;
        targetRotX = Math.max(-1.2, Math.min(1.2, targetRotX));
    });
    renderer.domElement.addEventListener("pointerup", ()=>{ isDragging = false; });

    window.addEventListener("wheel", (e)=>{
        const delta = Math.sign(e.deltaY);
        targetRotY += delta * 0.18;
        zoom = Math.max(10, Math.min(34, zoom + delta * 0.9));
    }, { passive:true });

    // Photo sphere
    const group = new THREE.Group();
    scene.add(group);

    THREE.Cache.enabled = true;
    const texLoader = new THREE.TextureLoader();
    texLoader.setCrossOrigin("anonymous");

    const geo = new THREE.PlaneGeometry(1.25, 1.85);
    const radius = 11.5;
    const cards = [];

    function randomOnSphere(r){
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2*v - 1);
        return new THREE.Vector3(
            r * Math.sin(phi) * Math.cos(theta),
            r * Math.cos(phi),
            r * Math.sin(phi) * Math.sin(theta)
        );
    }

    function addFrame(mesh){
        const frameGeo = new THREE.PlaneGeometry(1.32, 1.92);
        const frameMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.92, side: THREE.DoubleSide });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        frame.position.set(0,0,-0.01);
        mesh.add(frame);
    }

    function makeCard(p){
        const mat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });

        const url = getImgUrl(p, 1100);
        const t = texLoader.load(url, ()=>{}, undefined, ()=>{ mat.color.setHex(0xededed); });

        t.colorSpace = THREE.SRGBColorSpace;
        mat.map = t;

        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(randomOnSphere(radius));
        mesh.lookAt(0,0,0);
        mesh.rotateZ((Math.random()-0.5)*0.2);
        mesh.userData = p;
        mesh.scale.setScalar(1);

        addFrame(mesh);

        group.add(mesh);
        cards.push(mesh);
    }
    // === Player selectie helper ===
    // options:
    // - limit: number | null  (bv 60)
    // - onlyWithPhoto: boolean (true = alleen players met img)
    // - shuffle: boolean (true = random subset)
    function selectPlayers(list, { limit = null, onlyWithPhoto = false, shuffle = false } = {}) {
        let arr = Array.isArray(list) ? [...list] : [];

        if (onlyWithPhoto) {
            arr = arr.filter(p => {
                const src = String(p?.img || "").trim();
                return src.length > 0; // img is ingevuld (lokaal of extern)
            });
        }

        if (shuffle) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        if (typeof limit === "number" && Number.isFinite(limit) && limit > 0) {
            arr = arr.slice(0, limit);
        }

        return arr;
    }

    // players.forEach(makeCard);

    selectPlayers(players, { limit: 200, onlyWithPhoto: true, shuffle: true }).forEach(makeCard);

    // =========================
    // Hover tooltip
    // =========================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hovered = null;
    let autoRotate = true;

    function setTip(show, x=0, y=0, html=""){
        tip.style.opacity = show ? 1 : 0;
        if(show){
            tip.style.left = x + "px";
            tip.style.top  = y + "px";
            tip.innerHTML = html;
        }
    }

    window.addEventListener("pointermove", (e)=>{
        mouse.x = (e.clientX / innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(cards, true);

        const hitObj = hits.length ? (hits[0].object.userData?.name ? hits[0].object : hits[0].object.parent) : null;

        if(hitObj && hitObj.userData?.name){
            if(hovered !== hitObj){
                if(hovered) hovered.scale.setScalar(1);
                hovered = hitObj;
                hovered.scale.setScalar(1.22);
            }
            const p = hitObj.userData;
            setTip(true, e.clientX, e.clientY,
                `<b>${p.name}</b><div style="font-size:11px;color:#555;margin-top:2px">${p.role} • ${p.club} • ${p.season}</div>`
            );
        } else {
            if(hovered) hovered.scale.setScalar(1);
            hovered = null;
            setTip(false);
        }
    });

    // =========================
    // Fullscreen modal (Left text / Right photo) + word-by-word typing
    // =========================
    const modal = document.getElementById("modal");
    const modalClose = document.getElementById("modalClose");
    const mName = document.getElementById("mName");
    const mSub  = document.getElementById("mSub");
    const mType = document.getElementById("mType");
    const mMeta = document.getElementById("mMeta");
    const mLinks= document.getElementById("mLinks");
    const mImg  = document.getElementById("mImg");

    let typeTimer = null;

    function stopTyping(){
        if(typeTimer) clearInterval(typeTimer);
        typeTimer = null;
    }

    function typeWords(text, speedMs=55){
        stopTyping();
        mType.textContent = "";
        const words = String(text).split(" ");
        let i = 0;
        typeTimer = setInterval(()=>{
            if(i >= words.length){
                stopTyping();
                return;
            }
            mType.textContent += (i===0 ? "" : " ") + words[i];
            i++;
        }, speedMs);
    }

    function openModal(p){
        modal.style.display = "block";

        mName.textContent = p.name;
        mSub.textContent = `${p.club} • ${p.season}`;

        mImg.src = getImgUrl(p, 1600);

        const yearsActive = (() => {
            if (!p.debut || !p.lastMatch) return "–";
            const y1 = new Date(p.debut).getFullYear();
            const y2 = new Date(p.lastMatch).getFullYear();
            return `${y1}–${y2}`;
        })();

                    mSub.innerHTML = `
              <span>${p.role}</span> •
              <span>${p.club}</span> •
              <span>${yearsActive}</span></br>
              <span><b>Afkomst:</b> ${p.country}</span>

            `;

                    mMeta.innerHTML = `
              <div><b>Interlands</b><br>${p.matches}</div>
              <div><b>Goals</b><br>${p.goals}</div>
              <div><b>Aanvoerder</b><br>${p.captainMatches}</div>
              <div><b>Actief</b><br>${yearsActive}</div>
            `;


        // word-by-word animation
        typeWords(p.story || "Nederland is een netwerk van mensen en beweging. Via spelers zie je hoe Nederland zich buiten de grens verspreidt.", 45);
    }

    function closeModal(){
        modal.style.display = "none";
        stopTyping();
    }

    modalClose.addEventListener("click", closeModal);
    window.addEventListener("keydown", (e)=>{ if(e.key==="Escape") closeModal(); });

    // click outside inner closes
    modal.addEventListener("pointerdown", (e)=>{
        if(e.target === modal) closeModal();
    });

    // click on card opens modal
    window.addEventListener("click", ()=>{
        if(!hovered) return;
        openModal(hovered.userData);
    });

    // =========================
    // Buttons
    // =========================
    document.getElementById("btnReset").addEventListener("click", ()=>{
        targetRotX = 0; targetRotY = 0; zoom = 22;
    });

    document.getElementById("btnShuffle").addEventListener("click", ()=>{
        cards.forEach(m=>{
            m.position.copy(randomOnSphere(radius));
            m.lookAt(0,0,0);
            m.rotateZ((Math.random()-0.5)*0.2);
        });
    });

    document.getElementById("btnAuto").addEventListener("click", ()=>{
        autoRotate = !autoRotate;
        document.getElementById("btnAuto").textContent = autoRotate ? "AUTO ROTATE" : "AUTO OFF";
    });

    // =========================
    // Render loop
    // =========================
    function animate(){
        requestAnimationFrame(animate);

        rotX += (targetRotX - rotX) * 0.08;
        rotY += (targetRotY - rotY) * 0.08;

        if(autoRotate && !isDragging){
            targetRotY += 0.0035;
        }

        const r = zoom;
        const x = r * Math.sin(rotY) * Math.cos(rotX);
        const y = r * Math.sin(rotX);
        const z = r * Math.cos(rotY) * Math.cos(rotX);

        camera.position.set(x,y,z);
        camera.lookAt(0,0,0);

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });
</script>
</body>
</html>
